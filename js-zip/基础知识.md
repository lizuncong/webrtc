【注意】假如文件名有中文的话，那这里存放UTF-8编码数据，中文一般先转换为Unicode编码字符，然后用UTF-8编码方式存储(Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储, UTF-8是unicode的一种实现方式，unicode实现方式还有UTF-16和UTF-32)

【UTF-8小知识】UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则很简单，只有2条：

1️⃣对于单字节的符号，字节的第1位（字节的最高位）设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。

 2️⃣对于n字节的符号（n>1），第1个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码 比如：已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第3行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要3个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后1个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5




 ZIP格式的数据是按小端模式编排的，所以需要手动对ByteBuffer中的数据进行小端排序，那么，什么是小端模式，什么是大端模式呢？

1、大端模式：Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端，大端模式是跟人读写习惯是一致的，比如：数字0x12345678 与 0x11223344,大端模式表示如下：

低地址 ----------------------------------------------------> 高地址0x12  |  0x34  |  0x56  |  0x78 | 0x11  |  0x22  |  0x33  |  0x44

2、小端模式：Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端，比如：数字0x12345678 与 0x11223344,小端模式表示如下：

低地址 ----------------------------------------------------> 高地址0x78  |  0x56  |  0x34  |  0x12 | 0x44  |  0x33  |  0x22  |  0x11

那么，为啥会存在大小端不统一的问题呢？

既然大小端都有存在的必要性，那大小端模式各有啥优势呢？

【注意】字符是只有1个字节，故对于字符不存在大小端模式之分，只有大于1个字节的才分大小端模式




- [https://zhuanlan.zhihu.com/p/544976922?utm_id=0](https://zhuanlan.zhihu.com/p/544976922?utm_id=0)


- [https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT]